from app import db
from datetime import datetime
import json

class Plan(db.Model):
    __tablename__ = 'plans'
    
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(100), nullable=False)
    category = db.Column(db.String(50), nullable=False)  # mobile, internet, tv, bundle
    price = db.Column(db.Float, nullable=False)
    currency = db.Column(db.String(3), default='INR')
    duration = db.Column(db.String(20), default='monthly')  # monthly, yearly
    features = db.Column(db.Text, nullable=False)  # JSON string of features list
    description = db.Column(db.Text)
    is_popular = db.Column(db.Boolean, default=False)
    is_available = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    user_plans = db.relationship('UserPlan', back_populates='plan', lazy='dynamic')
    transactions = db.relationship('Transaction', back_populates='plan', lazy='dynamic')
    
    def __init__(self, name, category, price, features, description=None, 
                 currency='INR', duration='monthly', is_popular=False, is_available=True):
        self.name = name
        self.category = category
        self.price = price
        self.currency = currency
        self.duration = duration
        self.features = json.dumps(features) if isinstance(features, list) else features
        self.description = description
        self.is_popular = is_popular
        self.is_available = is_available
    
    def get_features(self):
        """Get features as a list"""
        try:
            return json.loads(self.features) if self.features else []
        except json.JSONDecodeError:
            return []
    
    def set_features(self, features_list):
        """Set features from a list"""
        self.features = json.dumps(features_list)
    
    def to_dict(self):
        """Convert plan object to dictionary"""
        return {
            'id': self.id,
            'name': self.name,
            'category': self.category,
            'price': self.price,
            'currency': self.currency,
            'duration': self.duration,
            'features': self.get_features(),
            'description': self.description,
            'is_popular': self.is_popular,
            'is_available': self.is_available,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None
        }
    
    def get_active_subscribers_count(self):
        """Get count of active subscribers for this plan"""
        return self.user_plans.filter_by(status='active').count()
    
    def get_total_revenue(self):
        """Get total revenue generated by this plan"""
        total = db.session.query(db.func.sum(Transaction.amount)).filter(
            Transaction.plan_id == self.id,
            Transaction.status == 'completed'
        ).scalar()
        return total or 0
    
    @staticmethod
    def get_by_category(category):
        """Get all plans by category"""
        return Plan.query.filter_by(category=category, is_available=True).all()
    
    @staticmethod
    def get_popular_plans():
        """Get all popular plans"""
        return Plan.query.filter_by(is_popular=True, is_available=True).all()
    
    @staticmethod
    def search_plans(query):
        """Search plans by name or description"""
        return Plan.query.filter(
            db.or_(
                Plan.name.contains(query),
                Plan.description.contains(query)
            ),
            Plan.is_available == True
        ).all()
    
    def __repr__(self):
        return f'<Plan {self.name}>'

class Transaction(db.Model):
    __tablename__ = 'transactions'
    
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    plan_id = db.Column(db.Integer, db.ForeignKey('plans.id'), nullable=False)
    amount = db.Column(db.Float, nullable=False)
    currency = db.Column(db.String(3), default='INR')
    status = db.Column(db.String(20), nullable=False, default='pending')  # pending, completed, failed, cancelled
    payment_method = db.Column(db.String(50))  # credit_card, debit_card, upi, wallet
    transaction_reference = db.Column(db.String(100))  # External payment gateway reference
    failure_reason = db.Column(db.String(255))  # Reason for failure if status is failed
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    user = db.relationship('User', back_populates='payment_history')
    plan = db.relationship('Plan', back_populates='transactions')
    
    def __init__(self, user_id, plan_id, amount, payment_method, currency='INR'):
        self.user_id = user_id
        self.plan_id = plan_id
        self.amount = amount
        self.currency = currency
        self.payment_method = payment_method
        import random
        import string
        random_id = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
        self.transaction_reference = f"TXN_{random_id}"
    
    def to_dict(self):
        """Convert transaction object to dictionary"""
        return {
            'id': self.id,
            'user_id': self.user_id,
            'plan_id': self.plan_id,
            'amount': self.amount,
            'currency': self.currency,
            'status': self.status,
            'payment_method': self.payment_method,
            'transaction_reference': self.transaction_reference,
            'failure_reason': self.failure_reason,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'plan': self.plan.to_dict() if self.plan else None
        }
    
    def mark_completed(self):
        """Mark transaction as completed"""
        self.status = 'completed'
        self.updated_at = datetime.utcnow()
    
    def mark_failed(self, reason=None):
        """Mark transaction as failed"""
        self.status = 'failed'
        self.failure_reason = reason
        self.updated_at = datetime.utcnow()
    
    def mark_cancelled(self):
        """Mark transaction as cancelled"""
        self.status = 'cancelled'
        self.updated_at = datetime.utcnow()
    
    @staticmethod
    def get_user_transactions(user_id, limit=10):
        """Get transactions for a specific user"""
        return Transaction.query.filter_by(user_id=user_id).order_by(
            Transaction.created_at.desc()
        ).limit(limit).all()
    
    @staticmethod
    def get_successful_transactions(start_date=None, end_date=None):
        """Get all successful transactions within date range"""
        query = Transaction.query.filter_by(status='completed')
        
        if start_date:
            query = query.filter(Transaction.created_at >= start_date)
        if end_date:
            query = query.filter(Transaction.created_at <= end_date)
            
        return query.order_by(Transaction.created_at.desc()).all()
    
    def __repr__(self):
        return f'<Transaction {self.transaction_reference}>'
